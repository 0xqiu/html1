<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ğŸš€ å¼ºå¼±å¯¹æ¯” Â· å¤šVSå¯¹æ¯”</title>
    <style>
        /* æ ·å¼ä¸æ‚¨ä¹‹å‰çš„ä¸€è‡´ï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´ï¼Œå®é™…ä½¿ç”¨æ—¶è¯·ä¿ç•™åŸæ · */
        /* ... å®Œæ•´æ ·å¼è§æ‚¨ä¹‹å‰æä¾›çš„ä»£ç  ... */
    </style>
</head>
<body>
    <div class="container">
        <!-- å¤´éƒ¨ã€å®æ—¶å¯¹æ¯”å¡ç‰‡ã€å¼€å§‹æŒ‰é’®ã€å¸ç§é€‰æ‹©ã€é¢‘ç‡æ§åˆ¶ã€è¿‘æœŸè®°å½•ç­‰éƒ¨åˆ†ä¸ä¹‹å‰å®Œå…¨ç›¸åŒ -->
        <!-- ... å®Œæ•´HTMLç»“æ„è§æ‚¨ä¹‹å‰æä¾›çš„ä»£ç  ... -->

        <!-- AIåˆ†æå¡ç‰‡ï¼ˆæŒ‰é’®éƒ¨åˆ†å·²åŒ…å«æ”¯æ’‘å‹åŠ›æŒ‰é’®ï¼‰ -->
        <div class="ai-card">
            <div class="ai-header">
                <div class="ai-title">
                    <span class="ai-icon">ğŸ¤–</span>
                    <span class="ai-title-text">DeepSeek AI Â· æŠ€æœ¯åˆ†æ</span>
                </div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="ai-btn orange" id="kline6hSimpleBtn">ğŸ“Š 6Hæ¶¨è·Œå¹…</button>
                    <button class="ai-btn" id="analyzeBtn">ğŸš€ æ·±åº¦åˆ†æ</button>
                    <button class="ai-btn purple" id="liqAnalysisBtn">ğŸ“‰ æ¸…ç®—åŒºé—´</button>
                    <button class="ai-btn green" id="supportResistanceBtn">ğŸ“Š æ”¯æ’‘å‹åŠ›</button>
                </div>
            </div>
            <div class="ai-content" id="aiContent">
                ğŸ¤– DeepSeek AI Â· 4å°æ—¶Kçº¿å¼ºå¼±å¯¹æ¯”<br>
                â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br>
                âœ… å®æ—¶å·®å€¼ï¼šè°æ¯”è°å¤šæ¶¨ï¼Ÿæ¯ç§’æ›´æ–°<br>
                âœ… 21é¡¹æŠ€æœ¯æŒ‡æ ‡ | ç»¼åˆè¯„åˆ† | æ”¯æ’‘é˜»åŠ›<br>
                â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br>
                ç‚¹å‡»ã€ŒğŸš€ æ·±åº¦åˆ†æã€è·å–å®Œæ•´å¯¹æ¯”æŠ¥å‘Š
            </div>
        </div>
    </div>

    <script>
        const COLORS = {
            bg: '#0B0E14', surface: '#1A1E26', primary: '#3B82F6',
            btc: '#F7931A', eth: '#627EEA', sol: '#9945FF',
            bnb: '#F3BA2F', nasdaq: '#00FF9D', ai: '#4F46E5',
        };

        const COINS = [
            { name: 'BTC', symbol: 'BTCUSDT', color: COLORS.btc, display: 'BTC/USDT', class: 'btc' },
            { name: 'ETH', symbol: 'ETHUSDT', color: COLORS.eth, display: 'ETH/USDT', class: 'eth' },
            { name: 'SOL', symbol: 'SOLUSDT', color: COLORS.sol, display: 'SOL/USDT', class: 'sol' },
            { name: 'BNB', symbol: 'BNBUSDT', color: COLORS.bnb, display: 'BNB/USDT', class: 'bnb' },
            { name: 'IXIC', symbol: 'nasdaq', color: COLORS.nasdaq, display: 'NASDAQ', class: 'nasdaq' }
        ];

        // ========== çŠ¶æ€å˜é‡ ==========
        let selectedCoins = [0, 4]; // é»˜è®¤é€‰ä¸­BTCå’ŒIXIC
        let cryptoInterval = 1;
        let nasdaqInterval = 6;
        let recordInterval = 10;

        let cryptoPrices = {};
        let nasdaqPrice = null;
        let basePrices = {};
        let historyData = [];
        let lastNasdaqUpdate = 0;

        let isRunning = false;
        let cryptoLoopTimer = null;
        let nasdaqLoopTimer = null;
        let recordLoopTimer = null;

        // æ–°å¢ï¼šå­˜å‚¨æ¯ä¸ªå¸ç§çš„æ”¯æ’‘å‹åŠ›ä½æ•°æ®
        let supportResistanceData = {}; // æ ¼å¼: { "BTC": "æ”¯æ’‘: 68420.00 / å‹åŠ›: 68450.00", ... }

        // ========== åˆå§‹åŒ– ==========
        function init() {
            createCoinButtons();
            updateStatusBar();
            updateNasdaqVisibility();
            renderVS();
            setInterval(updateTimeDisplay, 1000);
        }

        // ========== åˆ›å»ºå¸ç§æŒ‰é’® ==========
        function createCoinButtons() {
            const container = document.getElementById('coinButtons');
            const hint = document.getElementById('selectedCountHint');

            container.innerHTML = '';

            COINS.forEach((coin, i) => {
                const btn = document.createElement('button');
                btn.className = `coin-btn ${coin.class} ${selectedCoins.includes(i) ? 'selected' : ''}`;
                btn.textContent = coin.name;
                btn.onclick = () => toggleCoin(i);
                container.appendChild(btn);
            });

            hint.innerHTML = `å·²é€‰ ${selectedCoins.length}/4`;
        }

        // ========== åˆ‡æ¢å¸ç§é€‰æ‹© ==========
        function toggleCoin(index) {
            if (selectedCoins.includes(index)) {
                if (selectedCoins.length > 2) {
                    selectedCoins = selectedCoins.filter(i => i !== index);
                }
            } else {
                if (selectedCoins.length < 4) {
                    selectedCoins.push(index);
                } else {
                    selectedCoins.shift();
                    selectedCoins.push(index);
                }
            }

            createCoinButtons();
            // åˆ‡æ¢å¸ç§æ—¶æ¸…ç©ºä¹‹å‰çš„æ”¯æ’‘å‹åŠ›æ•°æ®ï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½ä¸å†å¯¹åº”
            supportResistanceData = {};
            renderVS();
            updateNasdaqVisibility();

            if (isRunning) {
                resetBasePrices();
            }
        }

        // ========== æ¸²æŸ“VSå¯¹æ¯”åŒºåŸŸï¼ˆä¿®æ”¹ç‰ˆï¼šè¯»å–æ”¯æ’‘å‹åŠ›æ•°æ®ï¼‰ ==========
        function renderVS() {
            const container = document.getElementById('vsContainer');

            if (selectedCoins.length < 2) {
                container.innerHTML = '<div class="price-loading">è¯·é€‰æ‹©è‡³å°‘ä¸¤ä¸ªå¸ç§</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < selectedCoins.length; i++) {
                const coin = COINS[selectedCoins[i]];
                const price = getCoinPrice(coin);
                const basePrice = basePrices[coin.symbol] || price;
                const change = basePrice ? ((price - basePrice) / basePrice * 100) : 0;

                // ä» supportResistanceData ä¸­è·å–è¯¥å¸ç§çš„æ”¯æ’‘å‹åŠ›æ–‡æœ¬ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤º "--"
                const srText = supportResistanceData[coin.name] || 'æ”¯æ’‘/å‹åŠ›: --';

                html += `
                    <div class="coin-block">
                        <div class="coin-header">
                            <span class="coin-logo" style="background: ${coin.color}; box-shadow: 0 0 8px ${coin.color};"></span>
                            <span class="coin-symbol" style="color: ${coin.color}">${coin.name}</span>
                        </div>
                        <div class="coin-price">${formatPrice(price, coin.name)}</div>
                        <div class="coin-base">åŸºå‡†: ${formatPrice(basePrice, coin.name)}</div>
                        <div class="coin-sr" id="sr-${coin.name}" style="font-size:12px; color:#F59E0B; margin-top:4px;">${srText}</div>
                        <div class="coin-change ${change >= 0 ? 'up' : 'down'}" 
                             style="background: ${change >= 0 ? 'rgba(16,185,129,0.1)' : 'rgba(239,68,68,0.1)'}">
                            ${change > 0 ? '+' : ''}${change.toFixed(2)}%
                        </div>
                    </div>
                `;

                if (i < selectedCoins.length - 1) {
                    html += '<span class="vs-badge">VS</span>';
                }
            }

            container.innerHTML = html;
            updateConclusion();
        }

        // ========== è·å–å¸ç§ä»·æ ¼ ==========
        function getCoinPrice(coin) {
            if (coin.symbol === 'nasdaq') {
                return nasdaqPrice;
            }
            return cryptoPrices[coin.symbol];
        }

        // ========== æ›´æ–°ç»“è®º ==========
        function updateConclusion() {
            if (selectedCoins.length < 2) {
                document.getElementById('conclusionText').textContent = 'è¯·é€‰æ‹©è‡³å°‘ä¸¤ä¸ªå¸ç§';
                return;
            }

            let maxChange = -Infinity;
            let minChange = Infinity;
            let maxCoin = null;
            let minCoin = null;

            selectedCoins.forEach(index => {
                const coin = COINS[index];
                const price = getCoinPrice(coin);
                const basePrice = basePrices[coin.symbol] || price;
                if (basePrice && price) {
                    const change = ((price - basePrice) / basePrice) * 100;
                    if (change > maxChange) {
                        maxChange = change;
                        maxCoin = coin;
                    }
                    if (change < minChange) {
                        minChange = change;
                        minCoin = coin;
                    }
                }
            });

            if (maxCoin && minCoin && maxCoin !== minCoin) {
                const diff = (maxChange - minChange).toFixed(2);
                document.getElementById('conclusionText').textContent =
                    `ğŸ”¥ ${maxCoin.name} æœ€å¼º Â· ğŸ’” ${minCoin.name} æœ€å¼± Â· å·®å€¼ ${diff}%`;
            } else {
                document.getElementById('conclusionText').textContent = 'ç­‰å¾…æ•°æ®...';
            }
        }

        // ========== æ ¼å¼åŒ–ä»·æ ¼ ==========
        function formatPrice(price, name) {
            if (!price) return 'â³';
            if (name === 'IXIC') return price.toFixed(2);
            return '$' + price.toFixed(2);
        }

        // ========== æ›´æ–°çº³æ–¯è¾¾å…‹æ˜¾ç¤º ==========
        function updateNasdaqVisibility() {
            const hasNasdaq = selectedCoins.some(i => COINS[i].name === 'IXIC');
            const container = document.getElementById('nasdaqFreqContainer');
            if (hasNasdaq) {
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        // ========== å¼€å§‹/åœæ­¢åˆ‡æ¢ ==========
        function toggleStart() {
            const button = document.getElementById('startButton');
            const dot = document.getElementById('statusDot');

            if (isRunning) {
                isRunning = false;
                button.innerHTML = 'â–¶ å¼€å§‹å®æ—¶æ•°æ®';
                button.classList.remove('stop');
                dot.classList.remove('stop');
                dot.style.background = '#EF4444';
                stopPriceFetcher();
                document.getElementById('refreshRateText').innerHTML = 'âš¡ å·²åœæ­¢';
            } else {
                isRunning = true;
                button.innerHTML = 'â¸ åœæ­¢å®æ—¶æ•°æ®';
                button.classList.add('stop');
                dot.classList.add('stop');
                dot.style.background = '#10B981';
                startPriceFetcher();
                document.getElementById('refreshRateText').innerHTML = 'âš¡ è¿è¡Œä¸­';
            }
        }

        // ========== åœæ­¢è·å– ==========
        function stopPriceFetcher() {
            if (cryptoLoopTimer) clearTimeout(cryptoLoopTimer);
            if (nasdaqLoopTimer) clearTimeout(nasdaqLoopTimer);
            if (recordLoopTimer) clearTimeout(recordLoopTimer);
        }

        // ========== é‡ç½®åŸºå‡†ä»·æ ¼ ==========
        function resetBasePrices() {
            basePrices = {};
            historyData = [];
            nasdaqPrice = null;
            cryptoPrices = {};
            lastNasdaqUpdate = 0;
            renderVS();
            updateRecords();
        }

        // ========== é¢‘ç‡è®¾ç½® ==========
        function setCryptoInterval(seconds, event) {
            cryptoInterval = seconds;
            document.getElementById('cryptoFreqValue').innerHTML = seconds + 'ç§’';
            document.querySelectorAll('#cryptoRefreshButtons .freq-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function setNasdaqInterval(seconds, event) {
            if (seconds < 6) seconds = 6;
            nasdaqInterval = seconds;
            const timesPerMinute = Math.floor(60 / seconds);
            document.getElementById('nasdaqFreqValue').innerHTML = seconds + 'ç§’';
            document.getElementById('nasdaqFreqNote').innerHTML = `${timesPerMinute}æ¬¡/åˆ†é’Ÿ (10æ¬¡/åˆ†é’Ÿé™åˆ¶)`;
            document.querySelectorAll('#nasdaqRefreshButtons .freq-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function setRecordInterval(seconds, event) {
            recordInterval = seconds;
            document.getElementById('recordFreqValue').innerHTML = seconds + 'ç§’';
            document.querySelectorAll('#recordRefreshButtons .freq-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // ========== è·å–ä»·æ ¼ ==========
        async function fetchCryptoPrice(symbol) {
            try {
                const res = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                if (!res.ok) return null;
                const data = await res.json();
                return parseFloat(data.price);
            } catch (error) {
                return null;
            }
        }

        async function fetchNasdaqPrice() {
            const now = Date.now();
            const timeSinceLast = (now - lastNasdaqUpdate) / 1000;
            if (timeSinceLast < nasdaqInterval) return null;

            try {
                const proxyUrl = 'https://corsproxy.io/?';
                const targetUrl = 'https://query1.finance.yahoo.com/v8/finance/chart/%5EIXIC';
                const response = await fetch(proxyUrl + encodeURIComponent(targetUrl));
                if (!response.ok) {
                    console.error('çº³æ–¯è¾¾å…‹ä»£ç†å¤±è´¥:', response.status);
                    return null;
                }
                const data = await response.json();
                if (data.chart?.result?.[0]?.meta?.regularMarketPrice) {
                    lastNasdaqUpdate = now;
                    return data.chart.result[0].meta.regularMarketPrice;
                } else {
                    console.error('çº³æ–¯è¾¾å…‹æ•°æ®æ ¼å¼æ— æ•ˆ');
                    return null;
                }
            } catch (error) {
                console.error('çº³æ–¯è¾¾å…‹è·å–é”™è¯¯:', error);
                return null;
            }
        }

        // ========== ä»·æ ¼å¾ªç¯ ==========
        function startPriceFetcher() {
            async function cryptoLoop() {
                if (!isRunning) return;
                for (let index of selectedCoins) {
                    const coin = COINS[index];
                    if (coin.symbol !== 'nasdaq') {
                        const price = await fetchCryptoPrice(coin.symbol);
                        if (price) {
                            cryptoPrices[coin.symbol] = price;
                            if (!basePrices[coin.symbol]) {
                                basePrices[coin.symbol] = price;
                                console.log(`âœ… è®¾ç½®${coin.name}åŸºå‡†: ${price}`);
                            }
                        }
                    }
                }
                renderVS();
                cryptoLoopTimer = setTimeout(cryptoLoop, cryptoInterval * 1000);
            }

            async function nasdaqLoop() {
                if (!isRunning) return;
                const price = await fetchNasdaqPrice();
                if (price) {
                    nasdaqPrice = price;
                    console.log('ğŸ“Š çº³æ–¯è¾¾å…‹æ›´æ–°:', price);
                    for (let index of selectedCoins) {
                        const coin = COINS[index];
                        if (coin.name === 'IXIC' && !basePrices[coin.symbol]) {
                            basePrices[coin.symbol] = price;
                        }
                    }
                    renderVS();
                } else if (selectedCoins.some(i => COINS[i].name === 'IXIC') && Date.now() - lastNasdaqUpdate > 300000) {
                    document.getElementById('conclusionText').textContent = 'âš ï¸ çº³æ–¯è¾¾å…‹æ•°æ®æ›´æ–°å»¶è¿Ÿï¼Œå¯èƒ½å¸‚åœºä¼‘å¸‚';
                }
                nasdaqLoopTimer = setTimeout(nasdaqLoop, nasdaqInterval * 1000);
            }

            async function recordLoop() {
                if (!isRunning) return;

                const now = new Date();
                let prices = [];
                let allValid = true;

                for (let index of selectedCoins) {
                    const coin = COINS[index];
                    const price = getCoinPrice(coin);
                    if (!price) {
                        allValid = false;
                        break;
                    }
                    prices.push({
                        name: coin.name,
                        price: price,
                        color: coin.color,
                        symbol: coin.symbol
                    });
                }

                if (allValid && prices.length === selectedCoins.length) {
                    let changes = [];
                    if (historyData.length > 0) {
                        const last = historyData[historyData.length - 1];
                        const lastPricesMap = {};
                        last.prices.forEach(p => { lastPricesMap[p.name] = p.price; });

                        changes = prices.map(p => {
                            const lastPrice = lastPricesMap[p.name];
                            if (lastPrice) {
                                return ((p.price - lastPrice) / lastPrice) * 100;
                            }
                            return 0;
                        });
                    } else {
                        changes = prices.map(() => 0);
                    }

                    historyData.push({
                        time: now,
                        prices: prices,
                        changes: changes
                    });

                    if (historyData.length > 5) {
                        historyData = historyData.slice(-5);
                    }

                    console.log('ğŸ“ è®°å½•ä¿å­˜:', prices.map(p => p.name).join('/'), 'æ¶¨è·Œå¹…:', changes.map(c => c.toFixed(2) + '%').join(', '));
                    updateRecords();
                }

                recordLoopTimer = setTimeout(recordLoop, recordInterval * 1000);
            }

            cryptoLoop();
            nasdaqLoop();
            recordLoop();
        }

        // ========== æ›´æ–°è®°å½•æ˜¾ç¤º ==========
        function updateRecords() {
            const mobileContainer = document.getElementById('mobileRecords');
            const recordsTable = document.getElementById('recordsTable');

            if (historyData.length === 0) {
                mobileContainer.innerHTML = '<div class="empty-state">â³ æš‚æ— è®°å½•ï¼Œç­‰å¾…æ•°æ®...</div>';
                if (recordsTable) recordsTable.innerHTML = '<div class="empty-state">â³ æš‚æ— è®°å½•</div>';
                return;
            }

            let mobileHtml = '';
            historyData.slice().reverse().forEach(data => {
                const timeStr = data.time.toLocaleTimeString();

                let rowsHtml = '';
                data.prices.forEach((p, idx) => {
                    const change = data.changes[idx];
                    const changeStr = (change > 0 ? '+' : '') + change.toFixed(2) + '%';
                    rowsHtml += `
                        <div class="record-row">
                            <span class="record-coin-name" style="color: ${p.color};">${p.name}</span>
                            <span class="record-coin-price">${formatPrice(p.price, p.name)}</span>
                            <span class="record-coin-change ${change >= 0 ? 'up' : 'down'}">${changeStr}</span>
                        </div>
                    `;
                });

                mobileHtml += `
                    <div class="record-item">
                        <div class="record-header">
                            <span class="record-pair">è®°å½•æ—¶é—´</span>
                            <span class="record-time-small">${timeStr}</span>
                        </div>
                        <div class="record-detail">
                            ${rowsHtml}
                        </div>
                    </div>
                `;
            });

            mobileContainer.innerHTML = mobileHtml;

            if (recordsTable) {
                let headerHtml = '<div class="table-row table-header">' +
                    '<span class="col-time">æ—¶é—´</span>';
                for (let i = 0; i < selectedCoins.length; i++) {
                    const coin = COINS[selectedCoins[i]];
                    headerHtml += `<span class="coin-cell coin-header" style="color:${coin.color}">${coin.name}</span>`;
                }
                headerHtml += '</div>';

                let rowsHtml = '';
                historyData.slice().reverse().forEach(data => {
                    let rowHtml = `<span class="col-time">${data.time.toLocaleTimeString()}</span>`;

                    data.prices.forEach((p, idx) => {
                        const change = data.changes[idx];
                        const changeStr = (change > 0 ? '+' : '') + change.toFixed(2) + '%';
                        rowHtml += `
                            <span class="coin-cell">
                                <div class="coin-price">${formatPrice(p.price, p.name)}</div>
                                <div class="coin-change ${change >= 0 ? 'up' : 'down'}">${changeStr}</div>
                            </span>
                        `;
                    });

                    rowsHtml += `<div class="table-row">${rowHtml}</div>`;
                });

                recordsTable.innerHTML = headerHtml + rowsHtml;
            }
        }

        // ========== æ›´æ–°æ—¶é—´æ˜¾ç¤º ==========
        function updateTimeDisplay() {
            document.getElementById('currentTime').innerHTML = `â±ï¸ ${new Date().toLocaleTimeString()}`;
        }

        // ========== çŠ¶æ€æ æ›´æ–° ==========
        function updateStatusBar() {
            document.getElementById('statusText').innerHTML = `å·²é€‰ ${selectedCoins.length}/4 å¸ç§`;
        }

        // ========== æ”¹è¿›ç‰ˆAIåˆ†æï¼ˆä½¿ç”¨DeepSeek APIï¼‰ ==========
        async function analyzeAll() {
            const aiContent = document.getElementById('aiContent');
            
            if (selectedCoins.length < 2) {
                aiContent.innerHTML = 'è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸¤ä¸ªå¸ç§';
                return;
            }
            
            aiContent.innerHTML = 'ğŸ§  DeepSeek AI æ­£åœ¨æ·±åº¦åˆ†æä¸­...';
            
            let coinDetails = [];
            let totalChange = 0;
            selectedCoins.forEach(index => {
                const coin = COINS[index];
                const price = getCoinPrice(coin);
                const base = basePrices[coin.symbol] || price;
                const change4h = base ? ((price - base) / base * 100) : 0;
                
                let recentChanges = [];
                for (let i = historyData.length - 1; i >= Math.max(0, historyData.length-3); i--) {
                    const record = historyData[i];
                    const pricePoint = record?.prices.find(p => p.name === coin.name);
                    if (pricePoint) {
                        const prevPrice = pricePoint.price;
                        const prevChange = ((price - prevPrice) / prevPrice) * 100;
                        recentChanges.push(prevChange.toFixed(2));
                    }
                }
                
                coinDetails.push({
                    name: coin.name,
                    price: price,
                    base: base,
                    change4h: change4h.toFixed(2),
                    recentChanges: recentChanges.length ? recentChanges.join('%, ') + '%' : 'æ— ',
                    color: coin.color
                });
                totalChange += change4h;
            });
            
            const avgChange = (totalChange / selectedCoins.length).toFixed(2);
            const maxChangeCoin = coinDetails.reduce((a, b) => parseFloat(a.change4h) > parseFloat(b.change4h) ? a : b);
            const minChangeCoin = coinDetails.reduce((a, b) => parseFloat(a.change4h) < parseFloat(b.change4h) ? a : b);
            const spread = (parseFloat(maxChangeCoin.change4h) - parseFloat(minChangeCoin.change4h)).toFixed(2);
            
            const prompt = buildAdvancedPrompt(coinDetails, { avgChange, maxChangeCoin, minChangeCoin, spread });
            const analysis = await callDeepSeekAPI(prompt);
            
            let formattedAnalysis = analysis
                .replace(/(æ¯”ç‰¹å¸|BTC|eth|ETH|sol|SOL|bnb|BNB|ixic|IXIC|çº³æ–¯è¾¾å…‹)/g, match => {
                    const coin = coinDetails.find(c => c.name === match.toUpperCase());
                    if (coin) return `<span style="color:${coin.color}; font-weight:bold;">${match}</span>`;
                    return match;
                })
                .replace(/(æ”¯æ’‘ä½|å‹åŠ›ä½|ç›®æ ‡ä½|æ­¢æŸä½)/g, '<span style="color:#F59E0B;">$1</span>')
                .replace(/(çœ‹æ¶¨|ä¹°å…¥|åšå¤š)/g, '<span class="up">$1</span>')
                .replace(/(çœ‹è·Œ|å–å‡º|åšç©º)/g, '<span class="down">$1</span>');
            
            aiContent.innerHTML = formattedAnalysis.replace(/\n/g, '<br>');
        }

        function buildAdvancedPrompt(coinDetails, meta) {
            let prompt = `ä½ æ˜¯ä¸€ä½é¡¶çº§çš„åŠ å¯†è´§å¸äº¤æ˜“å‘˜ã€‚è¯·åŸºäºä»¥ä¸‹çœŸå®å¸‚åœºæ•°æ®ï¼Œå¯¹ ${coinDetails.map(c => c.name).join('/')} è¿›è¡Œ**å®è´¨æ€§æŠ€æœ¯åˆ†æ**ï¼Œç»™å‡ºå¯æ‰§è¡Œçš„äº¤æ˜“å»ºè®®ã€‚\n\n`;
            
            prompt += `ã€å½“å‰å¸‚åœºæ•°æ®ã€‘\n`;
            coinDetails.forEach(c => {
                prompt += `- ${c.name}ï¼šä»·æ ¼ ${c.price.toFixed(2)}ï¼ŒåŸºå‡†ä»· ${c.base.toFixed(2)}ï¼Œæ¶¨è·Œå¹… ${c.change4h}%ï¼Œæœ€è¿‘3æ¬¡è®°å½•æ¶¨è·Œå¹…ï¼š${c.recentChanges}\n`;
            });
            
            prompt += `\nã€ç»„åˆæŒ‡æ ‡ã€‘\n`;
            prompt += `- å¹³å‡æ¶¨è·Œå¹…ï¼š${meta.avgChange}%\n`;
            prompt += `- æœ€å¼ºå¸ç§ï¼š${meta.maxChangeCoin.name} (${meta.maxChangeCoin.change4h}%)\n`;
            prompt += `- æœ€å¼±å¸ç§ï¼š${meta.minChangeCoin.name} (${meta.minChangeCoin.change4h}%)\n`;
            prompt += `- å¼ºå¼±å·®å€¼ï¼š${meta.spread}%\n`;
            
            prompt += `\nè¯·æŒ‰ä»¥ä¸‹ç»“æ„è¾“å‡ºåˆ†æï¼Œ**å¿…é¡»åŒ…å«å…·ä½“æ•°å­—å’Œä»·ä½**ï¼š\n\n`;
            prompt += `1ï¸âƒ£ **å½“å‰å¼ºå¼±æ’åº**ï¼šä»å¼ºåˆ°å¼±åˆ—å‡ºå¸ç§ï¼Œè¯´æ˜ç†ç”±ã€‚\n`;
            prompt += `2ï¸âƒ£ **å…³é”®ä»·ä½é¢„æµ‹**ï¼šåŸºäºå†å²æ³¢åŠ¨å¹…åº¦ï¼Œç»™å‡ºæœªæ¥24å°æ—¶å¯èƒ½çš„æ”¯æ’‘ä½å’Œå‹åŠ›ä½ã€‚\n`;
            prompt += `3ï¸âƒ£ **å¥—åˆ©æœºä¼šåˆ†æ**ï¼šæ˜¯å¦å­˜åœ¨å¼ºå¼±å¸ç§é…å¯¹å¥—åˆ©ç©ºé—´ï¼Ÿé¢„æœŸæ”¶ç›Šç‡ï¼Ÿ\n`;
            prompt += `4ï¸âƒ£ **é£é™©è¯„çº§**ï¼šç»™å‡º1-10åˆ†é£é™©è¯„åˆ†ï¼Œå¹¶è¯´æ˜ä¸»è¦é£é™©æ¥æºã€‚\n`;
            prompt += `5ï¸âƒ£ **å…·ä½“äº¤æ˜“å»ºè®®**ï¼š\n`;
            prompt += `   - å¦‚æœåšå¤šï¼šæœ€ä½³å…¥åœºåŒºé—´ã€ç¬¬ä¸€ç›®æ ‡ä½ã€æ­¢æŸä½ã€‚\n`;
            prompt += `   - å¦‚æœåšç©ºï¼šæœ€ä½³å…¥åœºåŒºé—´ã€ç¬¬ä¸€ç›®æ ‡ä½ã€æ­¢æŸä½ã€‚\n`;
            prompt += `   - å¦‚æœè§‚æœ›ï¼šç­‰å¾…ä»€ä¹ˆä¿¡å·ï¼Ÿ\n\n`;
            prompt += `è¯·ç”¨ä¸“ä¸šã€å®¢è§‚ã€ç›´æ¥çš„è¯­è¨€å›ç­”ï¼Œé¿å…æ¨¡ç³Šè¡¨è¿°ã€‚`;
            
            return prompt;
        }

        async function callDeepSeekAPI(prompt) {
            const apiKey = 'sk-b43ec0ccfb174cf1a172cd8687a1400b';
            
            try {
                const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: [
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç²¾é€šåŠ å¯†è´§å¸æŠ€æœ¯åˆ†æå’Œé‡åŒ–äº¤æ˜“çš„ä¸“å®¶ã€‚ä½ çš„åˆ†æå¿…é¡»æœ‰æ•°æ®æ”¯æ’‘ï¼Œç»™å‡ºå…·ä½“ä»·ä½å’Œå¯æ‰§è¡Œçš„å»ºè®®ã€‚' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.3,
                        max_tokens: 1200,
                        top_p: 0.9
                    })
                });
                
                const data = await response.json();
                if (data.error) {
                    console.error('APIé”™è¯¯:', data.error);
                    return `åˆ†ææœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼š${data.error.message}`;
                }
                return data.choices[0].message.content;
            } catch (error) {
                console.error('APIè°ƒç”¨å¤±è´¥:', error);
                return 'åˆ†ææœåŠ¡è¿æ¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚';
            }
        }

        // ========== 6å°æ—¶æ¶¨è·Œå¹…ç®€æ´å¯¹æ¯” ==========
        async function analyze6hSimple() {
            const aiContent = document.getElementById('aiContent');
            
            if (selectedCoins.length < 2) {
                aiContent.innerHTML = 'è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸¤ä¸ªå¸ç§';
                return;
            }
            
            aiContent.innerHTML = 'ğŸ“Š æ­£åœ¨è·å–6å°æ—¶æ¶¨è·Œå¹…æ•°æ®...';
            
            let results = [];
            
            for (let index of selectedCoins) {
                const coin = COINS[index];
                
                try {
                    let change6h = null;
                    
                    if (coin.symbol === 'nasdaq') {
                        const currentPrice = getCoinPrice(coin);
                        const basePrice = basePrices[coin.symbol];
                        
                        if (currentPrice && basePrice) {
                            change6h = ((currentPrice - basePrice) / basePrice) * 100;
                        } else {
                            results.push({
                                name: coin.name,
                                change: 'æ•°æ®ä¸è¶³',
                                color: coin.color
                            });
                            continue;
                        }
                    } else {
                        const url = `https://api.binance.com/api/v3/klines?symbol=${coin.symbol}&interval=6h&limit=1`;
                        const response = await fetch(url);
                        
                        if (!response.ok) {
                            results.push({
                                name: coin.name,
                                change: 'è·å–å¤±è´¥',
                                color: coin.color
                            });
                            continue;
                        }
                        
                        const data = await response.json();
                        
                        if (data && data.length > 0) {
                            const openPrice = parseFloat(data[0][1]);
                            const closePrice = parseFloat(data[0][4]);
                            change6h = ((closePrice - openPrice) / openPrice) * 100;
                        } else {
                            results.push({
                                name: coin.name,
                                change: 'æ— æ•°æ®',
                                color: coin.color
                            });
                            continue;
                        }
                    }
                    
                    results.push({
                        name: coin.name,
                        change: change6h,
                        color: coin.color
                    });
                    
                } catch (error) {
                    console.error(`è·å–${coin.name}6å°æ—¶æ•°æ®å¤±è´¥:`, error);
                    results.push({
                        name: coin.name,
                        change: 'é”™è¯¯',
                        color: coin.color
                    });
                }
            }
            
            let report = 'ğŸ“ˆ **æœ€è¿‘6å°æ—¶æ¶¨è·Œå¹…å¯¹æ¯”**\n';
            report += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n';
            
            const validResults = results.filter(r => typeof r.change === 'number');
            const invalidResults = results.filter(r => typeof r.change !== 'number');
            
            validResults.sort((a, b) => b.change - a.change);
            
            validResults.forEach(item => {
                const changeStr = item.change > 0 ? `+${item.change.toFixed(2)}%` : `${item.change.toFixed(2)}%`;
                report += `â€¢ **${item.name}**: ${changeStr}\n`;
            });
            
            invalidResults.forEach(item => {
                report += `âŒ **${item.name}**: ${item.change}\n`;
            });
            
            report += '\n';
            
            if (validResults.length >= 2) {
                report += '**å¼ºå¼±å¯¹æ¯”**\n';
                for (let i = 0; i < validResults.length - 1; i++) {
                    for (let j = i + 1; j < validResults.length; j++) {
                        const diff = (validResults[i].change - validResults[j].change).toFixed(2);
                        report += `â€¢ ${validResults[i].name} vs ${validResults[j].name}: `;
                        
                        if (validResults[i].change >= 0 && validResults[j].change >= 0) {
                            if (diff > 0) {
                                report += `<span class="up">${validResults[i].name} å¤šæ¶¨ ${diff}%</span>`;
                            } else if (diff < 0) {
                                report += `<span class="up">${validResults[j].name} å¤šæ¶¨ ${Math.abs(diff)}%</span>`;
                            } else {
                                report += `<span class="equal">æ¶¨å¹…æŒå¹³</span>`;
                            }
                        } else if (validResults[i].change < 0 && validResults[j].change < 0) {
                            if (diff > 0) {
                                report += `<span class="up">${validResults[i].name} å°‘è·Œ ${diff}%</span>`;
                            } else if (diff < 0) {
                                report += `<span class="up">${validResults[j].name} å°‘è·Œ ${Math.abs(diff)}%</span>`;
                            } else {
                                report += `<span class="equal">è·Œå¹…æŒå¹³</span>`;
                            }
                        } else {
                            if (diff > 0) {
                                report += `<span class="up">${validResults[i].name} ä¸Šæ¶¨, ${validResults[j].name} ä¸‹è·Œ, å·®å€¼ ${diff}%</span>`;
                            } else {
                                report += `<span class="up">${validResults[j].name} ä¸Šæ¶¨, ${validResults[i].name} ä¸‹è·Œ, å·®å€¼ ${Math.abs(diff)}%</span>`;
                            }
                        }
                        report += '\n';
                    }
                }
            }
            
            let formattedReport = report
                .replace(/(æ¯”ç‰¹å¸|BTC|eth|ETH|sol|SOL|bnb|BNB|ixic|IXIC|çº³æ–¯è¾¾å…‹)/g, match => {
                    const coin = results.find(r => r.name === match.toUpperCase());
                    if (coin && coin.color) return `<span style="color:${coin.color}; font-weight:bold;">${match}</span>`;
                    return match;
                })
                .replace(/(å¤šæ¶¨|å°‘è·Œ|ä¸Šæ¶¨|ä¸‹è·Œ)/g, '<span class="up">$1</span>');
            
            aiContent.innerHTML = formattedReport.replace(/\n/g, '<br>');
        }

        // ========== å¤šå¸ç§è®¢å•ç°¿æ¸…ç®—åŒºé—´åˆ†æ (limit=1000) ==========
        async function analyzeLiquidation() {
            const aiContent = document.getElementById('aiContent');
            
            const cryptoIndices = selectedCoins.filter(i => COINS[i].name !== 'IXIC');
            if (cryptoIndices.length === 0) {
                aiContent.innerHTML = 'âš ï¸ è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªåŠ å¯†å¸ç§ (BTC/ETH/SOL/BNB) è¿›è¡Œæ¸…ç®—åŒºé—´åˆ†æã€‚';
                return;
            }

            aiContent.innerHTML = `ğŸ“‰ æ­£åœ¨è·å– ${cryptoIndices.length} ä¸ªå¸ç§çš„è®¢å•ç°¿æ•°æ®ï¼Œåˆ†ææ¸…ç®—åŒºé—´...`;

            let analyses = [];
            
            for (let i = 0; i < cryptoIndices.length; i++) {
                const coinIndex = cryptoIndices[i];
                const coin = COINS[coinIndex];
                const symbol = coin.symbol;
                
                aiContent.innerHTML = `ğŸ“‰ [${i+1}/${cryptoIndices.length}] æ­£åœ¨åˆ†æ ${coin.name} è®¢å•ç°¿...`;
                
                try {
                    const depthUrl = `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=1000`;
                    const depthRes = await fetch(depthUrl);
                    if (!depthRes.ok) throw new Error(`${coin.name}æ·±åº¦æ•°æ®è·å–å¤±è´¥`);
                    const depth = await depthRes.json();
                    
                    let currentPrice = getCoinPrice(coin);
                    if (!currentPrice) {
                        const price = await fetchCryptoPrice(symbol);
                        if (price) currentPrice = price;
                    }
                    
                    const bids = depth.bids.map(b => ({ price: parseFloat(b[0]), qty: parseFloat(b[1]) }));
                    const asks = depth.asks.map(a => ({ price: parseFloat(a[0]), qty: parseFloat(a[1]) }));
                    
                    const totalBidQty = bids.reduce((sum, b) => sum + b.qty, 0);
                    const totalAskQty = asks.reduce((sum, a) => sum + a.qty, 0);
                    
                    const farthestBidPrice = bids[bids.length - 1]?.price || currentPrice;
                    const farthestAskPrice = asks[asks.length - 1]?.price || currentPrice;
                    const bidRangePercent = currentPrice ? ((currentPrice - farthestBidPrice) / currentPrice * 100).toFixed(2) : 'æœªçŸ¥';
                    const askRangePercent = currentPrice ? ((farthestAskPrice - currentPrice) / currentPrice * 100).toFixed(2) : 'æœªçŸ¥';
                    
                    const topBidClusters = [...bids].sort((a, b) => b.qty - a.qty).slice(0, 5);
                    const topAskClusters = [...asks].sort((a, b) => b.qty - a.qty).slice(0, 5);
                    
                    const prompt = `ä½ æ˜¯ä¸€ä½åˆçº¦äº¤æ˜“ä¸“å®¶ã€‚ä»¥ä¸‹æ˜¯ ${coin.name} çš„å¸å®‰è®¢å•ç°¿æ·±åº¦æ•°æ®æ‘˜è¦ï¼ˆåŸºäºå‰1000æ¡£ï¼‰ï¼š

ã€å½“å‰ä»·æ ¼ã€‘${currentPrice ? currentPrice.toFixed(2) : 'æœªçŸ¥'}

ã€æ•´ä½“æ·±åº¦ç»Ÿè®¡ã€‘
- ä¹°å•æ€»æŒ‚å•é‡: ${totalBidQty.toFixed(3)} ${coin.name}
- å–å•æ€»æŒ‚å•é‡: ${totalAskQty.toFixed(3)} ${coin.name}
- ä¹°ç›˜è¦†ç›–èŒƒå›´: å‘ä¸‹çº¦ ${bidRangePercent}%
- å–ç›˜è¦†ç›–èŒƒå›´: å‘ä¸Šçº¦ ${askRangePercent}%

ã€æŒ‚å•é‡æœ€å¤§çš„5ä¸ªä¹°å•ä»·ä½ï¼ˆæ½œåœ¨æ”¯æ’‘åŒºï¼‰ã€‘
${topBidClusters.map(b => `ä»·æ ¼ ${b.price.toFixed(2)} : æ•°é‡ ${b.qty.toFixed(3)}`).join('\n')}

ã€æŒ‚å•é‡æœ€å¤§çš„5ä¸ªå–å•ä»·ä½ï¼ˆæ½œåœ¨å‹åŠ›åŒºï¼‰ã€‘
${topAskClusters.map(a => `ä»·æ ¼ ${a.price.toFixed(2)} : æ•°é‡ ${a.qty.toFixed(3)}`).join('\n')}

ã€ä»·æ ¼åˆ†å¸ƒæ¦‚å†µã€‘
- ä¹°å•æœ€è¿œä»·æ ¼: ${farthestBidPrice.toFixed(2)}
- å–å•æœ€è¿œä»·æ ¼: ${farthestAskPrice.toFixed(2)}

è¯·åŸºäºä»¥ä¸Šæ•°æ®è¿›è¡Œåˆ†æï¼š
1ï¸âƒ£ **æ½œåœ¨æ¸…ç®—å¯†é›†åŒº**ï¼šåŸºäºæŒ‚å•é‡æœ€å¤§çš„ä»·ä½ï¼Œåˆ†æå“ªäº›ä»·æ ¼åŒºé—´å¯èƒ½æˆä¸ºæ¸…ç®—è§¦å‘ç‚¹ã€‚åŒæ—¶è€ƒè™‘æ›´è¿œè·ç¦»çš„è®¢å•å †ç§¯æƒ…å†µã€‚
2ï¸âƒ£ **çŸ­æœŸæ”¯æ’‘ä¸å‹åŠ›**ï¼šç»“åˆæŒ‚å•é‡åˆ†å¸ƒå’Œæ•´ä½“è¦†ç›–èŒƒå›´ï¼Œç»™å‡ºå½“å‰ä»·æ ¼é™„è¿‘çš„å¼ºæ”¯æ’‘ä½å’Œå¼ºå‹åŠ›ä½ï¼ˆå…·ä½“åˆ°å°æ•°ç‚¹å2ä½ï¼‰ã€‚
3ï¸âƒ£ **å¤šç©ºé£é™©æç¤º**ï¼šå¦‚æœä»·æ ¼è·Œç ´æˆ–çªç ´æŸä¸ªå¯†é›†åŒºï¼Œå¯èƒ½å¼•å‘çš„è¿é”ååº”ã€‚æ ¹æ®ä¹°ç›˜/å–ç›˜æ€»æŒ‚å•é‡å¯¹æ¯”ï¼Œåˆ¤æ–­å“ªä¸€æ–¹æ›´å®¹æ˜“è¢«å‡»ç©¿ã€‚
4ï¸âƒ£ **äº¤æ˜“å»ºè®®**ï¼šåŸºäºæ¸…ç®—å¯†åº¦å’Œæ•´ä½“æ·±åº¦ï¼Œç»™å‡ºåˆç†çš„æ­¢æŸ/æ­¢ç›ˆå‚è€ƒä½ï¼Œä»¥åŠæ½œåœ¨çš„åè½¬åŒºåŸŸã€‚

è¯·ç”¨ä¸“ä¸šã€å®¢è§‚çš„è¯­è¨€å›ç­”ï¼Œç»™å‡ºå…·ä½“ä»·ä½ã€‚`;
                    
                    const analysis = await callDeepSeekAPI(prompt);
                    
                    analyses.push({
                        coinName: coin.name,
                        color: coin.color,
                        content: analysis
                    });
                    
                } catch (error) {
                    console.error(`${coin.name}æ¸…ç®—åŒºé—´åˆ†æå¤±è´¥:`, error);
                    analyses.push({
                        coinName: coin.name,
                        color: coin.color,
                        content: `âŒ åˆ†æå¤±è´¥: ${error.message}`
                    });
                }
            }
            
            let finalReport = '';
            for (let item of analyses) {
                finalReport += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                finalReport += `<span style="color:${item.color}; font-size:1.1em; font-weight:bold;">ğŸ“Š ${item.coinName} æ¸…ç®—åŒºé—´åˆ†æ</span>\n`;
                finalReport += `${item.content}\n\n`;
            }
            
            aiContent.innerHTML = finalReport.replace(/\n/g, '<br>');
        }

        // ========== ä¿®å¤ç‰ˆï¼šè·å–æ”¯æ’‘å‹åŠ›ä½ï¼ˆä¹°ä¸€/å–ä¸€ï¼‰å¹¶æ›´æ–°åˆ°å¸ç§ä¸‹æ–¹ï¼Œæ•°æ®å­˜å…¥supportResistanceData ==========
        async function updateSupportResistance() {
            const cryptoIndices = selectedCoins.filter(i => COINS[i].name !== 'IXIC');
            
            if (cryptoIndices.length === 0) {
                document.getElementById('aiContent').innerHTML = 'âš ï¸ è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåŠ å¯†å¸ç§ (BTC/ETH/SOL/BNB) æŸ¥çœ‹æ”¯æ’‘å‹åŠ›ã€‚';
                return;
            }

            // æ˜¾ç¤ºæç¤ºä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
            document.getElementById('aiContent').innerHTML = 'ğŸ“Š æ­£åœ¨è·å–æ”¯æ’‘/å‹åŠ›ä½...';

            // ä¸´æ—¶å­˜å‚¨æœ¬æ¬¡è·å–çš„æ•°æ®
            let newData = {};

            for (let index of cryptoIndices) {
                const coin = COINS[index];
                const symbol = coin.symbol;
                try {
                    // è·å–æ·±åº¦æ•°æ®ï¼ˆå‰500æ¡£ï¼Œæ»¡è¶³ç”¨æˆ·è¦æ±‚ï¼‰
                    const depthUrl = `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=500`;
                    const res = await fetch(depthUrl);
                    if (!res.ok) {
                        console.error(`${coin.name}æ·±åº¦è¯·æ±‚å¤±è´¥: ${res.status}`);
                        continue;
                    }
                    const depth = await res.json();
                    
                    // ä¹°ä¸€ä»·ï¼ˆæœ€é«˜ä¹°ä»·ï¼‰ä½œä¸ºæ”¯æ’‘ï¼Œå–ä¸€ä»·ï¼ˆæœ€ä½å–ä»·ï¼‰ä½œä¸ºå‹åŠ›
                    const bidPrice = depth.bids[0] ? parseFloat(depth.bids[0][0]) : null;
                    const askPrice = depth.asks[0] ? parseFloat(depth.asks[0][0]) : null;
                    
                    if (bidPrice && askPrice) {
                        newData[coin.name] = `æ”¯æ’‘: ${bidPrice.toFixed(2)} / å‹åŠ›: ${askPrice.toFixed(2)}`;
                    } else {
                        newData[coin.name] = 'æ”¯æ’‘/å‹åŠ›: æš‚æ— æ•°æ®';
                    }
                } catch (error) {
                    console.error(`è·å–${coin.name}æ”¯æ’‘å‹åŠ›å¤±è´¥:`, error);
                    newData[coin.name] = 'æ”¯æ’‘/å‹åŠ›: è·å–å¤±è´¥';
                }
            }

            // æ›´æ–°å…¨å±€å˜é‡
            supportResistanceData = newData;

            // é‡æ–°æ¸²æŸ“VSåŒºåŸŸï¼Œä½¿æ–°çš„æ”¯æ’‘å‹åŠ›æ•°æ®æ˜¾ç¤ºå‡ºæ¥
            renderVS();

            // æ›´æ–°æç¤ºä¿¡æ¯
            const count = Object.keys(newData).length;
            if (count > 0) {
                document.getElementById('aiContent').innerHTML = `âœ… å·²æ›´æ–° ${count} ä¸ªå¸ç§çš„æ”¯æ’‘/å‹åŠ›ä½ã€‚`;
            } else {
                document.getElementById('aiContent').innerHTML = 'âŒ æœªèƒ½è·å–ä»»ä½•æ”¯æ’‘/å‹åŠ›æ•°æ®ï¼Œè¯·ç¨åé‡è¯•ã€‚';
            }
        }

        // ç»‘å®šæŒ‰é’®äº‹ä»¶
        document.getElementById('analyzeBtn').onclick = analyzeAll;
        document.getElementById('kline6hSimpleBtn').onclick = analyze6hSimple;
        document.getElementById('liqAnalysisBtn').onclick = analyzeLiquidation;
        document.getElementById('supportResistanceBtn').onclick = updateSupportResistance;

        window.onload = init;
    </script>
</body>
</html>